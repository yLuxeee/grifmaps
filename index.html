<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>Grifmaps</title>
    <style>
      :root {
        color-scheme: light dark;
        font-family: "Inter", "Segoe UI", system-ui, -apple-system, BlinkMacSystemFont,
          sans-serif;
        --app-bg: radial-gradient(circle at top left, #edf2f7, #c3dafe);
        --toolbar-bg: linear-gradient(135deg, rgba(255, 255, 255, 0.96), rgba(241, 245, 249, 0.9));
        --toolbar-text: #0f172a;
        --panel-bg: rgba(255, 255, 255, 0.9);
        --panel-border: rgba(148, 163, 184, 0.35);
        --hint-bg: rgba(226, 232, 240, 0.6);
        --field-border: rgba(15, 23, 42, 0.85);
        --field-bg: #d4d4d8;
        --goal-outline: rgba(15, 23, 42, 0.35);
      }

      * {
        box-sizing: border-box;
      }

      body {
        margin: 0;
        min-height: 100vh;
        display: flex;
        align-items: center;
        justify-content: center;
        background: var(--app-bg);
        padding: clamp(16px, 3vw, 32px);
        color: var(--toolbar-text);
      }

      body.dark {
        --app-bg: radial-gradient(circle at top left, #0f172a, #1e293b);
        --toolbar-bg: linear-gradient(135deg, rgba(15, 23, 42, 0.95), rgba(30, 41, 59, 0.9));
        --toolbar-text: #e2e8f0;
        --panel-bg: rgba(15, 23, 42, 0.9);
        --panel-border: rgba(148, 163, 184, 0.2);
        --hint-bg: rgba(30, 41, 59, 0.75);
        --field-border: rgba(226, 232, 240, 0.65);
        --field-bg: #1f2937;
        --goal-outline: rgba(148, 163, 184, 0.6);
      }

       body.is-loading {
        overflow: hidden;
      }

      .app {
        width: min(98vw, 1280px);
        display: grid;
        gap: 16px;
        opacity: 0;
        animation: app-fade-in 0.6s ease 1.8s forwards;
      }

      .toolbar {
        display: flex;
        flex-wrap: wrap;
        align-items: center;
        gap: 14px;
        padding: 14px 18px;
        border-radius: 20px;
        background: var(--toolbar-bg);
        box-shadow: 0 24px 50px rgba(15, 23, 42, 0.18);
        border: 1px solid var(--panel-border);
        backdrop-filter: blur(10px);
      }

      .toolbar h1 {
        font-size: 1.1rem;
        font-weight: 600;
        color: var(--toolbar-text);
        margin: 0 12px 0 0;
      }

      .toolbar button,
      .toolbar label,
      .toolbar select {
        font-size: 0.95rem;
        display: inline-flex;
        align-items: center;
        gap: 6px;
      }

      .toolbar button {
        padding: 8px 14px;
        border-radius: 999px;
        border: 1px solid rgba(148, 163, 184, 0.4);
        background: rgba(226, 232, 240, 0.7);
        color: var(--toolbar-text);
        cursor: pointer;
        transition: background 0.2s ease;
        font-weight: 600;
      }

      .toolbar button[data-mode].active {
        background: linear-gradient(120deg, #2563eb, #1d4ed8);
        color: #f8fafc;
        border-color: transparent;
        box-shadow: 0 10px 20px rgba(37, 99, 235, 0.3);
      }

      .toolbar button:hover {
        background: rgba(203, 213, 245, 0.9);
      }

      .toolbar input[type="color"] {
        width: 44px;
        height: 30px;
        border-radius: 8px;
        border: 1px solid rgba(148, 163, 184, 0.6);
        padding: 0;
        background: none;
        cursor: pointer;
        box-shadow: 0 6px 14px rgba(15, 23, 42, 0.12);
      }

      .toolbar input[type="range"] {
        accent-color: #2563eb;
      }

      .toolbar select {
        padding: 8px 12px;
        border-radius: 999px;
        border: 1px solid rgba(203, 213, 225, 0.7);
        background: rgba(248, 250, 252, 0.9);
        color: var(--toolbar-text);
        font-weight: 600;
        cursor: pointer;
      }

      .field-wrapper {
        display: flex;
        justify-content: center;
        position: relative;
      }

      .field-stage {
        position: relative;
      }

      .field {
        position: relative;
        --field-width: min(96vw, 1152px);
        --dot-size: 52px;
        width: var(--field-width);
        height: min(calc(var(--field-width) / 1.12), 820px);
        border-radius: 28px;
        border: 10px solid var(--field-border);
        background-color: var(--field-bg);

        /* Default grid */
        background-image:
          linear-gradient(
            90deg,
            rgba(107, 114, 128, 0.25) 0,
            rgba(107, 114, 128, 0.25) 1px,
            transparent 1px,
            transparent 72px
          ),
          linear-gradient(
            180deg,
            rgba(107, 114, 128, 0.25) 0,
            rgba(107, 114, 128, 0.25) 1px,
            transparent 1px,
            transparent 72px
          );
        background-size: 72px 72px;

        box-shadow: 0 30px 60px rgba(15, 23, 42, 0.35);
        overflow: hidden;
      }

      .field.canvas-bg {
        background-size: cover;
        background-position: center;
        background-repeat: no-repeat;
      }

      .field canvas,
      .connector-layer,
      .goal-point,
      .marker {
        position: absolute;
      }

      .connector-layer {
        inset: 0;
        width: 100%;
        height: 100%;
        pointer-events: none;
      }

      .connector-layer line {
        stroke-width: 2.4;
        stroke-linecap: round;
        opacity: 0.75;
      }

      #drawingCanvas {
        inset: 0;
        width: 100%;
        height: 100%;
        display: block;
        touch-action: none;
      }

      .marker {
        width: var(--dot-size);
        aspect-ratio: 1 / 1;
        border-radius: 50%;
        transform: translate(-50%, -50%);
        box-shadow: 0 10px 18px rgba(15, 23, 42, 0.35);
        display: grid;
        place-items: center;
        color: #f8fafc;
        font-weight: 700;
        letter-spacing: 0.04em;
        user-select: none;
        transition: transform 0.2s ease;
      }

      .marker::after {
        content: attr(data-label);
      }

      .marker.red {
        background: radial-gradient(circle at 30% 30%, #ff9b9b, #b91c1c 65%);
      }

      .marker.blue {
        background: radial-gradient(circle at 30% 30%, #93c5fd, #1d4ed8 65%);
      }

      .marker.highlight {
        background: radial-gradient(circle at 30% 30%, #fef08a, #facc15 70%);
        color: #92400e;
      }

      .field.moving .marker:active {
        transform: translate(-50%, -50%) scale(1.05);
      }

      .goal-point {
        width: 18px;
        height: 18px;
        border-radius: 50%;
        transform: translate(-50%, -50%);
        pointer-events: none;
        opacity: 0.85;
        box-shadow: 0 0 12px rgba(15, 23, 42, 0.45);
        border: 2px solid var(--goal-outline);
      }

      .goal-point::before {
        content: "";
        position: absolute;
        inset: 4px;
        border-radius: 50%;
        background: #f8fafc;
        opacity: 0.85;
      }

      .goal-point::after {
        content: attr(data-label);
        position: absolute;
        top: -6px;
        left: 50%;
        transform: translate(-50%, -100%);
        padding: 2px 8px;
        border-radius: 999px;
        font-size: 0.7rem;
        font-weight: 700;
        letter-spacing: 0.03em;
        background: var(--panel-bg);
        color: var(--toolbar-text);
        border: 1px solid var(--panel-border);
        text-transform: uppercase;
        white-space: nowrap;
      }

      .goal-point.red {
        background: #b91c1c;
      }

      .goal-point.blue {
        background: #1d4ed8;
      }

     

      

      .marker.is-hidden {
        display: none;
      }

      .hint {
        margin-left: auto;
        font-size: 0.85rem;
        color: var(--toolbar-text);
        font-weight: 600;
        opacity: 0.9;
        padding: 6px 10px;
        border-radius: 999px;
        background: var(--hint-bg);
        border: 1px solid rgba(203, 213, 225, 0.7);
      }

      .settings-panel {
        background: var(--panel-bg);
        border-radius: 18px;
        padding: 12px;
        box-shadow: 0 18px 32px rgba(15, 23, 42, 0.2);
        backdrop-filter: blur(6px);
        display: grid;
        gap: 12px;
        width: 220px;
        position: absolute;
        right: calc(100% + 16px);
        top: 0;
      }

      .saved-panel {
        background: var(--panel-bg);
        border-radius: 18px;
        padding: 12px;
        box-shadow: 0 18px 32px rgba(15, 23, 42, 0.2);
        backdrop-filter: blur(6px);
        display: grid;
        gap: 12px;
        width: 220px;
        position: absolute;
        left: calc(100% + 16px);
        top: 0;
      }

      .settings-toggle {
        width: 100%;
        padding: 10px 14px;
        border-radius: 999px;
        border: none;
        background: #2563eb;
        color: #f8fafc;
        font-weight: 700;
        cursor: pointer;
      }

      .settings-drawer {
        display: grid;
        gap: 12px;
      }

      .settings-drawer[hidden] {
        display: none;
      }

      .settings-drawer h2 {
        font-size: 0.95rem;
        margin: 0;
        color: var(--toolbar-text);
      }

      .settings-list {
        display: grid;
        gap: 10px;
      }

      .settings-item {
        display: grid;
        gap: 8px;
        padding: 10px;
        border-radius: 14px;
        background: rgba(248, 250, 252, 0.9);
        border: 1px solid #e2e8f0;
      }

      .settings-item label {
        font-size: 0.85rem;
        color: var(--toolbar-text);
        font-weight: 600;
        display: grid;
        gap: 6px;
      }

      .settings-item input[type="text"] {
        border-radius: 10px;
        border: 1px solid #cbd5e1;
        padding: 8px 10px;
        font-weight: 600;
      }

      .settings-item input[type="color"] {
        width: 100%;
        height: 34px;
        border-radius: 10px;
        border: 1px solid #cbd5e1;
        padding: 0;
        background: none;
        cursor: pointer;
      }

      .settings-item button,
      #restoreDots {
        padding: 8px 12px;
        border-radius: 999px;
        border: 1px solid rgba(148, 163, 184, 0.6);
        background: rgba(248, 250, 252, 0.9);
        color: #0f172a;
        font-weight: 600;
        cursor: pointer;
      }

      .saved-panel h2 {
        font-size: 0.95rem;
        margin: 0;
        color: var(--toolbar-text);
      }

      .saved-panel input[type="text"] {
        border-radius: 10px;
        border: 1px solid #cbd5e1;
        padding: 8px 10px;
        font-weight: 600;
        width: 100%;
      }

      body.dark .settings-item {
        background: rgba(30, 41, 59, 0.85);
        border-color: rgba(148, 163, 184, 0.25);
      }

      body.dark .settings-item input[type="text"],
      body.dark .saved-panel input[type="text"] {
        background: rgba(15, 23, 42, 0.6);
        border-color: rgba(148, 163, 184, 0.3);
        color: #e2e8f0;
      }

      .saved-panel button {
        width: 100%;
        padding: 10px 14px;
        border-radius: 999px;
        border: none;
        background: #0f172a;
        color: #f8fafc;
        font-weight: 700;
        cursor: pointer;
      }

      .saved-list {
        display: grid;
        gap: 10px;
      }

      .saved-list button {
        border-radius: 12px;
        border: 1px solid rgba(148, 163, 184, 0.6);
        background: rgba(248, 250, 252, 0.9);
        color: #0f172a;
        font-weight: 600;
        padding: 8px 10px;
        cursor: pointer;
        text-align: left;
      }

      .sr-only {
        position: absolute;
        width: 1px;
        height: 1px;
        padding: 0;
        margin: -1px;
        overflow: hidden;
        clip: rect(0, 0, 0, 0);
        white-space: nowrap;
        border: 0;
      }

      .splash {
        position: fixed;
        inset: 0;
        display: grid;
        place-items: center;
        background: radial-gradient(circle at top left, #e2e8f0, #bfdbfe);
        z-index: 999;
        animation: splash-fade-out 0.8s ease 1.1s forwards;
      }

      .splash__logo {
        font-size: clamp(2.5rem, 8vw, 4.5rem);
        font-weight: 800;
        letter-spacing: 0.08em;
        color: #1e3a8a;
        text-transform: uppercase;
        animation: splash-fade-in 0.8s ease forwards;
      }

      @keyframes splash-fade-in {
        from {
          opacity: 0;
          transform: translateY(10px);
        }
        to {
          opacity: 1;
          transform: translateY(0);
        }
      }

      @keyframes splash-fade-out {
        to {
          opacity: 0;
          visibility: hidden;
        }
      }

      @keyframes app-fade-in {
        to {
          opacity: 1;
        }
      }

      @media (max-width: 640px) {
        .toolbar {
          gap: 10px;
        }

        .toolbar h1 {
          flex-basis: 100%;
        }

        .hint {
          flex-basis: 100%;
          margin-left: 0;
        }

        .field-wrapper {
          justify-content: stretch;
        }

        .field-stage {
          display: grid;
          gap: 12px;
        }

        .settings-panel {
          position: static;
          width: 100%;
        }

        .saved-panel {
          position: static;
          width: 100%;
        }
      }
    </style>
  </head>
   <body class="is-loading">
    <div class="splash" id="splashScreen" aria-hidden="true">
      <div class="splash__logo">GrifMaps</div>
    </div>
    <main class="app" aria-labelledby="appTitle">
      <div class="toolbar" role="group" aria-label="Drawing controls">
        <h1 id="appTitle">Grifmaps</h1>

        <button type="button" data-mode="move" class="active">Move Pieces</button>
        <button type="button" data-mode="draw">Draw Routes</button>
        

        <label>
          <span class="sr-only">Brush color</span>
          <input type="color" id="colorPicker" value="#ef4444" aria-label="Brush color" />
        </label>

        <label for="brushSize">Brush size</label>
        <input type="range" id="brushSize" min="2" max="24" value="8" aria-label="Brush Size" />

        <label for="backgroundSelect">Background</label>
        <select id="backgroundSelect" aria-label="Background preset">
          <option value="grid" selected>Grid (Default)</option>
          <option value="football">Football Field</option>
          <option value="basketball">Basketball Court</option>
          <option value="chalk">Chalkboard</option>
        </select>

        
        <button type="button" id="darkModeToggle" aria-pressed="false">Dark Mode</button>
        <button type="button" id="downloadPng">Download PNG</button>
        <button type="button" id="clearCanvas">Clear Drawing</button>

        <span class="hint">Tip: Right-click a marker to toggle its goal line.</span>
      </div>

      <div class="field-wrapper">
        <div class="field-stage">
          <aside class="settings-panel" aria-label="Marker settings">
            <button type="button" class="settings-toggle" id="settingsToggle" aria-expanded="true">
              Settings
            </button>
            <div class="settings-drawer" id="settingsDrawer">
              <h2>Dot controls</h2>
              <div class="settings-item">
                <label for="dotSize">Dot size</label>
                <input type="range" id="dotSize" min="28" max="90" value="52" />
              </div>
              <div class="settings-list" id="settingsList"></div>
              <button type="button" id="restoreDots">Restore all dots</button>
            </div>
          </aside>
          <aside class="saved-panel" aria-label="Saved positions">
            <h2>Saved positions</h2>
            <label class="sr-only" for="saveName">Position name</label>
            <input type="text" id="saveName" placeholder="Position name" />
            <button type="button" id="savePosition">Save Position</button>
            <div class="saved-list" id="savedList" role="list"></div>
          </aside>
          <section class="field moving" id="field" aria-label="Interactive field">
            <canvas id="drawingCanvas" aria-hidden="true"></canvas>

            <svg class="connector-layer" viewBox="0 0 100 100" preserveAspectRatio="none" aria-hidden="true"></svg>

            <div class="goal-point red" data-label="Goal" data-goal="red" data-x="10" data-y="50" style="left: 10%; top: 50%;" aria-hidden="true"></div>
            <div class="goal-point blue" data-label="Goal" data-goal="blue" data-x="90" data-y="50" style="left: 90%; top: 50%;" aria-hidden="true"></div>

            <div class="marker red" data-label="R1" data-x="18" data-y="22" role="button"></div>
            <div class="marker red" data-label="R2" data-x="32" data-y="68" role="button"></div>
            <div class="marker red" data-label="R3" data-x="50" data-y="32" role="button"></div>
            <div class="marker red" data-label="R4" data-x="70" data-y="78" role="button"></div>

            <div class="marker blue" data-label="B1" data-x="82" data-y="26" role="button"></div>
            <div class="marker blue" data-label="B2" data-x="24" data-y="48" role="button"></div>
            <div class="marker blue" data-label="B3" data-x="54" data-y="60" role="button"></div>
            <div class="marker blue" data-label="B4" data-x="40" data-y="84" role="button"></div>

            
          </section>
        </div>
      </div>
    </main>

    <script>
      const field = document.getElementById("field");
      const canvas = document.getElementById("drawingCanvas");
      const colorPicker = document.getElementById("colorPicker");
      const brushSizeControl = document.getElementById("brushSize");
      const clearButton = document.getElementById("clearCanvas");
      const dotSizeControl = document.getElementById("dotSize");
      const restoreDotsButton = document.getElementById("restoreDots");
      const darkModeToggle = document.getElementById("darkModeToggle");
      const downloadButton = document.getElementById("downloadPng");
      const modeButtons = document.querySelectorAll("[data-mode]");
      const backgroundSelect = document.getElementById("backgroundSelect");

      const markers = Array.from(document.querySelectorAll(".marker"));
      
      const connectorLayer = field.querySelector(".connector-layer");
      const markerConnections = new Map();
      const settingsToggle = document.getElementById("settingsToggle");
      const settingsDrawer = document.getElementById("settingsDrawer");
      const settingsList = document.getElementById("settingsList");
      const saveNameInput = document.getElementById("saveName");
      const savePositionButton = document.getElementById("savePosition");
      const savedList = document.getElementById("savedList");
      const ctx = canvas.getContext("2d");

      const goalTargets = {
        red: field.querySelector('[data-goal="red"]'),
        blue: field.querySelector('[data-goal="blue"]'),
      };

      let mode = "move";
      let activeMarker = null;
      
      
      let activePointerId = null;
      let pointerOffset = { x: 0, y: 0 };
      let isDrawing = false;
      let lastPoint = null;
      const savedPositions = [];
      const history = {
        past: [],
        future: [],
      };
      let dragStartState = null;
      let dragStartPosition = null;

      

      function clamp(value, min, max) {
        return Math.min(Math.max(value, min), max);
      }

      function resizeCanvas() {
        const rect = field.getBoundingClientRect();
        const prev = document.createElement("canvas");
        prev.width = canvas.width;
        prev.height = canvas.height;
        prev.getContext("2d").drawImage(canvas, 0, 0);

        canvas.width = Math.round(rect.width);
        canvas.height = Math.round(rect.height);

        ctx.clearRect(0, 0, canvas.width, canvas.height);
        ctx.drawImage(prev, 0, 0, prev.width, prev.height, 0, 0, canvas.width, canvas.height);
      }

      function pointerPercentages(event, rect) {
        return {
          x: ((event.clientX - rect.left) / rect.width) * 100,
          y: ((event.clientY - rect.top) / rect.height) * 100,
        };
      }

      function positionMarker(marker, xPercent, yPercent) {
        marker.style.left = `${xPercent}%`;
        marker.style.top = `${yPercent}%`;
        marker.dataset.x = xPercent.toFixed(2);
        marker.dataset.y = yPercent.toFixed(2);
        updateConnector(marker);
      }

      function refreshMarkerPositions() {
        markers.forEach((marker) => {
          const x = parseFloat(marker.dataset.x);
          const y = parseFloat(marker.dataset.y);
          positionMarker(marker, x, y);
        });
      }

      

      function getMarkerGoalKey(marker) {
        if (marker.classList.contains("red")) return "red";
        if (marker.classList.contains("blue")) return "blue";
        return null;
      }

      function createConnector(marker) {
        if (!connectorLayer || markerConnections.has(marker)) return;
        const line = document.createElementNS("http://www.w3.org/2000/svg", "line");
        const strokeColor = marker.dataset.color || (marker.classList.contains("red") ? "#ef4444" : "#3b82f6");
        line.setAttribute("stroke", strokeColor);
        connectorLayer.appendChild(line);
        markerConnections.set(marker, line);
        updateConnector(marker);
      }

      function removeConnector(marker) {
        const line = markerConnections.get(marker);
        if (!line) return;
        line.remove();
        markerConnections.delete(marker);
      }

      function updateConnector(marker) {
        if (!connectorLayer || !markerConnections.has(marker)) return;
        const line = markerConnections.get(marker);
        const goalKey = getMarkerGoalKey(marker);
        const goalPoint = goalKey ? goalTargets[goalKey] : null;
        if (!line || !goalPoint) return;

        const strokeColor = marker.dataset.color || (marker.classList.contains("red") ? "#ef4444" : "#3b82f6");
        line.setAttribute("stroke", strokeColor);

        const markerX = parseFloat(marker.dataset.x);
        const markerY = parseFloat(marker.dataset.y);
        const goalX = parseFloat(goalPoint.dataset.x);
        const goalY = parseFloat(goalPoint.dataset.y);

        line.setAttribute("x1", markerX);
        line.setAttribute("y1", markerY);
        line.setAttribute("x2", goalX);
        line.setAttribute("y2", goalY);
      }

      function refreshConnectorPositions() {
        markers.forEach(updateConnector);
      }

      function getMarkerState(marker) {
        return {
          x: parseFloat(marker.dataset.x),
          y: parseFloat(marker.dataset.y),
          hidden: marker.classList.contains("is-hidden"),
          label: marker.dataset.label || "",
          color: marker.dataset.color || "",
        };
      }

      function getCurrentState() {
        return {
          markers: markers.map((marker) => getMarkerState(marker)),
          
        };
      }

      function applyMarkerState(marker, state) {
        if (!state) return;
        positionMarker(marker, state.x, state.y);
        marker.classList.toggle("is-hidden", Boolean(state.hidden));
        marker.dataset.label = state.label || "";
        if (state.color) {
          applyMarkerColor(marker, state.color);
        } else {
          applyMarkerColor(marker, getDefaultMarkerColor(marker));
        }
        if (marker.classList.contains("is-hidden")) {
          removeConnector(marker);
        } else if (marker.classList.contains("highlight")) {
          createConnector(marker);
        }
      }

      function applyState(state) {
        if (!state) return;
        state.markers.forEach((markerState, index) => {
          const marker = markers[index];
          if (!marker) return;
          applyMarkerState(marker, markerState);
        });
        
        buildMarkerSettings();
        refreshConnectorPositions();
      }

      function pushHistory(snapshot) {
        history.past.push(snapshot);
        if (history.past.length > 100) {
          history.past.shift();
        }
        history.future = [];
      }

      function undo() {
        if (history.past.length === 0) return;
        const current = getCurrentState();
        const previous = history.past.pop();
        history.future.push(current);
        applyState(previous);
      }

      function redo() {
        if (history.future.length === 0) return;
        const current = getCurrentState();
        const next = history.future.pop();
        history.past.push(current);
        applyState(next);
      }

      function handleDotSizeChange(value) {
        const clamped = clamp(parseFloat(value), 28, 90);
        field.style.setProperty("--dot-size", `${clamped}px`);
      }

      function setDarkMode(isDark) {
        document.body.classList.toggle("dark", isDark);
        if (darkModeToggle) {
          darkModeToggle.setAttribute("aria-pressed", String(isDark));
        }
      }

      function getDotSizePixels() {
        const size = parseFloat(getComputedStyle(field).getPropertyValue("--dot-size"));
        return Number.isNaN(size) ? 52 : size;
      }

      function drawGridBackground(ctx2d, width, height) {
        const styles = getComputedStyle(field);
        ctx2d.fillStyle = styles.backgroundColor || "#d4d4d8";
        ctx2d.fillRect(0, 0, width, height);

        ctx2d.strokeStyle = "rgba(107, 114, 128, 0.25)";
        ctx2d.lineWidth = 1;
        const spacing = 72;
        for (let x = 0; x <= width; x += spacing) {
          ctx2d.beginPath();
          ctx2d.moveTo(x, 0);
          ctx2d.lineTo(x, height);
          ctx2d.stroke();
        }
        for (let y = 0; y <= height; y += spacing) {
          ctx2d.beginPath();
          ctx2d.moveTo(0, y);
          ctx2d.lineTo(width, y);
          ctx2d.stroke();
        }
      }

      function loadImage(src) {
        return new Promise((resolve, reject) => {
          const image = new Image();
          image.onload = () => resolve(image);
          image.onerror = reject;
          image.src = src;
        });
      }

      async function renderSnapshot() {
        const rect = field.getBoundingClientRect();
        const dpr = window.devicePixelRatio || 1;
        const exportCanvas = document.createElement("canvas");
        exportCanvas.width = Math.round(rect.width * dpr);
        exportCanvas.height = Math.round(rect.height * dpr);
        const exportCtx = exportCanvas.getContext("2d");
        exportCtx.scale(dpr, dpr);

        if (backgroundSelect.value === "grid") {
          drawGridBackground(exportCtx, rect.width, rect.height);
        } else {
          const bg = bgPresets[backgroundSelect.value];
          if (bg) {
            const image = await loadImage(bg.slice(5, -2));
            exportCtx.drawImage(image, 0, 0, rect.width, rect.height);
          } else {
            drawGridBackground(exportCtx, rect.width, rect.height);
          }
        }

        exportCtx.drawImage(canvas, 0, 0, rect.width, rect.height);

        markers.forEach((marker) => {
          if (marker.classList.contains("is-hidden")) return;
          if (!marker.classList.contains("highlight")) return;
          const goalKey = getMarkerGoalKey(marker);
          const goalPoint = goalKey ? goalTargets[goalKey] : null;
          if (!goalPoint) return;
          const markerX = (parseFloat(marker.dataset.x) / 100) * rect.width;
          const markerY = (parseFloat(marker.dataset.y) / 100) * rect.height;
          const goalX = (parseFloat(goalPoint.dataset.x) / 100) * rect.width;
          const goalY = (parseFloat(goalPoint.dataset.y) / 100) * rect.height;
          exportCtx.strokeStyle = marker.dataset.color || getDefaultMarkerColor(marker);
          exportCtx.lineWidth = 2.4;
          exportCtx.beginPath();
          exportCtx.moveTo(markerX, markerY);
          exportCtx.lineTo(goalX, goalY);
          exportCtx.stroke();
        });

        const dotSize = getDotSizePixels();
        markers.forEach((marker, index) => {
          if (marker.classList.contains("is-hidden")) return;
          const markerX = (parseFloat(marker.dataset.x) / 100) * rect.width;
          const markerY = (parseFloat(marker.dataset.y) / 100) * rect.height;
          const color = marker.dataset.color || getDefaultMarkerColor(marker);
          exportCtx.fillStyle = color;
          exportCtx.beginPath();
          exportCtx.arc(markerX, markerY, dotSize / 2, 0, Math.PI * 2);
          exportCtx.fill();

          const label = marker.dataset.label || `Dot ${index + 1}`;
          exportCtx.fillStyle = getReadableTextColor(color);
          exportCtx.font = `${Math.max(12, dotSize * 0.3)}px "Inter", system-ui, sans-serif`;
          exportCtx.textAlign = "center";
          exportCtx.textBaseline = "middle";
          exportCtx.fillText(label, markerX, markerY);
        });

        Object.values(goalTargets).forEach((goalPoint) => {
          const goalX = (parseFloat(goalPoint.dataset.x) / 100) * rect.width;
          const goalY = (parseFloat(goalPoint.dataset.y) / 100) * rect.height;
          const goalColor = goalPoint.classList.contains("red") ? "#ef4444" : "#3b82f6";
          exportCtx.fillStyle = goalColor;
          exportCtx.beginPath();
          exportCtx.arc(goalX, goalY, 9, 0, Math.PI * 2);
          exportCtx.fill();
          exportCtx.strokeStyle = getComputedStyle(goalPoint).borderColor || "rgba(15, 23, 42, 0.35)";
          exportCtx.lineWidth = 2;
          exportCtx.stroke();

          exportCtx.fillStyle = getComputedStyle(document.body).color || "#0f172a";
          exportCtx.font = "11px \"Inter\", system-ui, sans-serif";
          exportCtx.textAlign = "center";
          exportCtx.textBaseline = "bottom";
          exportCtx.fillText("GOAL", goalX, goalY - 12);
        });

        return exportCanvas;
      }

      function setMode(newMode) {
        mode = newMode;

        modeButtons.forEach((button) => {
          const isActive = button.dataset.mode === newMode;
          button.classList.toggle("active", isActive);
        });

        field.classList.toggle("drawing-mode", newMode === "draw");
        
        field.classList.toggle("moving", newMode === "move");

        // Markers should not be draggable in draw mode
        markers.forEach((marker) => {
          marker.style.pointerEvents = newMode === "move" ? "auto" : "none";
        });

      

        
      }

      function onMarkerPointerDown(event) {
        // Right click toggles connector
        if (event.button === 2) {
          event.preventDefault();
          const marker = event.currentTarget;
          const shouldHighlight = !marker.classList.contains("highlight");
          marker.classList.toggle("highlight", shouldHighlight);
          if (shouldHighlight) createConnector(marker);
          else removeConnector(marker);
          updateConnector(marker);
          return;
        }

        if (mode !== "move") return;

        event.preventDefault();
        activeMarker = event.currentTarget;
        activePointerId = event.pointerId;

        const rect = field.getBoundingClientRect();
        const pointerPercents = pointerPercentages(event, rect);
        const markerX = parseFloat(activeMarker.dataset.x);
        const markerY = parseFloat(activeMarker.dataset.y);

        pointerOffset = {
          x: pointerPercents.x - markerX,
          y: pointerPercents.y - markerY,
        };

        dragStartState = getCurrentState();
        dragStartPosition = { x: markerX, y: markerY };

        activeMarker.setPointerCapture(activePointerId);
      }

      function onMarkerPointerMove(event) {
        if (!activeMarker || event.pointerId !== activePointerId) return;

        const rect = field.getBoundingClientRect();
        const { x, y } = pointerPercentages(event, rect);
        const markerWidthPercent = ((activeMarker.offsetWidth / 2) / rect.width) * 100;
        const markerHeightPercent = ((activeMarker.offsetHeight / 2) / rect.height) * 100;

        const targetX = clamp(x - pointerOffset.x, markerWidthPercent, 100 - markerWidthPercent);
        const targetY = clamp(y - pointerOffset.y, markerHeightPercent, 100 - markerHeightPercent);

        positionMarker(activeMarker, targetX, targetY);
      }

      function endMarkerDrag(event) {
        if (event.pointerId !== activePointerId) return;
        activeMarker?.releasePointerCapture(activePointerId);
        if (activeMarker && dragStartState && dragStartPosition) {
          const currentX = parseFloat(activeMarker.dataset.x);
          const currentY = parseFloat(activeMarker.dataset.y);
          if (currentX !== dragStartPosition.x || currentY !== dragStartPosition.y) {
            pushHistory(dragStartState);
          }
        }
        activeMarker = null;
        activePointerId = null;
        dragStartState = null;
        dragStartPosition = null;
      }

     

      function startDrawing(event) {
        if (mode !== "draw") return;
        event.preventDefault();
        isDrawing = true;
        lastPoint = getCanvasCoordinates(event);
      }

      function draw(event) {
        if (!isDrawing) return;
        const point = getCanvasCoordinates(event);

        ctx.strokeStyle = colorPicker.value;
        ctx.lineWidth = parseFloat(brushSizeControl.value);
        ctx.lineCap = "round";
        ctx.lineJoin = "round";

        ctx.beginPath();
        ctx.moveTo(lastPoint.x, lastPoint.y);
        ctx.lineTo(point.x, point.y);
        ctx.stroke();

        lastPoint = point;
      }

      function stopDrawing() {
        isDrawing = false;
      }

      function getCanvasCoordinates(event) {
        const rect = field.getBoundingClientRect();
        const scaleX = canvas.width / rect.width;
        const scaleY = canvas.height / rect.height;
        return {
          x: (event.clientX - rect.left) * scaleX,
          y: (event.clientY - rect.top) * scaleY,
        };
      }

      function clearCanvas() {
        ctx.clearRect(0, 0, canvas.width, canvas.height);
      }

      function clampChannel(value) {
        return clamp(Math.round(value), 0, 255);
      }

      function hexToRgb(hex) {
        const normalized = hex.replace("#", "");
        const value = normalized.length === 3
          ? normalized.split("").map((ch) => ch + ch).join("")
          : normalized;
        const int = parseInt(value, 16);
        return {
          r: (int >> 16) & 255,
          g: (int >> 8) & 255,
          b: int & 255,
        };
      }

      function rgbToHex({ r, g, b }) {
        return `#${[r, g, b].map((channel) => channel.toString(16).padStart(2, "0")).join("")}`;
      }

      function adjustColor(hex, amount) {
        const { r, g, b } = hexToRgb(hex);
        return rgbToHex({
          r: clampChannel(r + amount),
          g: clampChannel(g + amount),
          b: clampChannel(b + amount),
        });
      }

      function getReadableTextColor(hex) {
        const { r, g, b } = hexToRgb(hex);
        const luminance = (0.2126 * r + 0.7152 * g + 0.0722 * b) / 255;
        return luminance > 0.6 ? "#0f172a" : "#f8fafc";
      }

      function applyMarkerColor(marker, color, applyStyle = true) {
        marker.dataset.color = color;
        if (applyStyle) {
          const highlight = adjustColor(color, 50);
          const shade = adjustColor(color, -40);
          marker.style.background = `radial-gradient(circle at 30% 30%, ${highlight}, ${shade} 65%)`;
          marker.style.color = getReadableTextColor(color);
        }
        updateConnector(marker);
      }

      function getDefaultMarkerColor(marker) {
        return marker.classList.contains("red") ? "#ef4444" : "#3b82f6";
      }

      function buildMarkerSettings() {
        if (!settingsList) return;
        settingsList.innerHTML = "";

        markers.forEach((marker, index) => {
          const wrapper = document.createElement("div");
          wrapper.className = "settings-item";

          const nameLabel = document.createElement("label");
          nameLabel.textContent = `Dot label (${marker.dataset.label || `Dot ${index + 1}`})`;
          const nameInput = document.createElement("input");
          nameInput.type = "text";
          nameInput.value = marker.dataset.label || "";
          nameInput.setAttribute("aria-label", `Label for ${marker.dataset.label || `dot ${index + 1}`}`);

          nameInput.addEventListener("input", () => {
            marker.dataset.label = nameInput.value;
          });

          nameLabel.appendChild(nameInput);

          const colorLabel = document.createElement("label");
          colorLabel.textContent = "Dot color";
          const colorInput = document.createElement("input");
          colorInput.type = "color";
          colorInput.value = marker.dataset.color || getDefaultMarkerColor(marker);
          colorInput.setAttribute("aria-label", `Color for ${marker.dataset.label || `dot ${index + 1}`}`);

          colorInput.addEventListener("input", () => {
            applyMarkerColor(marker, colorInput.value);
          });

          colorLabel.appendChild(colorInput);

          const toggleButton = document.createElement("button");
          toggleButton.type = "button";
          toggleButton.textContent = marker.classList.contains("is-hidden") ? "Restore dot" : "Delete dot";
          toggleButton.addEventListener("click", () => {
            const snapshot = getCurrentState();
            marker.classList.toggle("is-hidden");
            if (marker.classList.contains("is-hidden")) {
              removeConnector(marker);
            } else if (marker.classList.contains("highlight")) {
              createConnector(marker);
            }
            toggleButton.textContent = marker.classList.contains("is-hidden") ? "Restore dot" : "Delete dot";
            pushHistory(snapshot);
          });

          wrapper.appendChild(nameLabel);
          wrapper.appendChild(colorLabel);
          wrapper.appendChild(toggleButton);
          settingsList.appendChild(wrapper);
        });
      }

      function initializeMarkerColors() {
        markers.forEach((marker) => {
          applyMarkerColor(marker, marker.dataset.color || getDefaultMarkerColor(marker), false);
        });
      }

      function collectMarkerPositions() {
        return markers.map((marker) => ({
          x: parseFloat(marker.dataset.x),
          y: parseFloat(marker.dataset.y),
        }));
      }

      function applyMarkerPositions(positionSet) {
        positionSet.forEach((position, index) => {
          const marker = markers[index];
          if (!marker || !position) return;
          positionMarker(marker, position.x, position.y);
        });
      }

      function renderSavedPositions() {
        if (!savedList) return;
        savedList.innerHTML = "";

        savedPositions.forEach((position, index) => {
          const button = document.createElement("button");
          button.type = "button";
          button.textContent = position.name;
          button.addEventListener("click", () => {
            applyMarkerPositions(position.markers);
          });
          button.setAttribute("role", "listitem");
          button.dataset.index = String(index);
          savedList.appendChild(button);
        });
      }

      function saveCurrentPosition() {
        const fallbackName = `Position ${savedPositions.length + 1}`;
        const name = saveNameInput?.value.trim() || fallbackName;
        savedPositions.push({
          name,
          markers: collectMarkerPositions(),
        });
        if (saveNameInput) saveNameInput.value = "";
        renderSavedPositions();
      }


      // ---- Background presets (inline SVG data URLs) ----
      const bgPresets = {
        grid: null,
        football: svgDataUrl(`
          <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 1200 800">
            <defs>
              <linearGradient id="g" x1="0" y1="0" x2="0" y2="1">
                <stop offset="0" stop-color="#166534"/>
                <stop offset="1" stop-color="#14532d"/>
              </linearGradient>
              <pattern id="stripes" width="160" height="160" patternUnits="userSpaceOnUse">
                <rect width="160" height="160" fill="none"/>
                <rect x="0" y="0" width="80" height="160" fill="rgba(255,255,255,0.06)"/>
              </pattern>
            </defs>
            <rect width="1200" height="800" fill="url(#g)"/>
            <rect width="1200" height="800" fill="url(#stripes)"/>
            <g stroke="rgba(255,255,255,0.72)" stroke-width="4">
              <rect x="60" y="60" width="1080" height="680" fill="none" rx="24"/>
              <line x1="600" y1="60" x2="600" y2="740"/>
            </g>
            <g stroke="rgba(255,255,255,0.45)" stroke-width="2">
              ${Array.from({length: 20}, (_, i) => {
                const x = 60 + i * (1080/20);
                return `<line x1="${x}" y1="60" x2="${x}" y2="740"/>`;
              }).join("")}
            </g>
            <g fill="rgba(255,255,255,0.75)" font-family="system-ui, sans-serif" font-size="26" font-weight="700">
              <text x="90" y="110">10</text><text x="90" y="700">10</text>
              <text x="1090" y="110" text-anchor="end">10</text><text x="1090" y="700" text-anchor="end">10</text>
            </g>
          </svg>
        `),
        basketball: svgDataUrl(`
          <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 1200 800">
            <defs>
              <linearGradient id="wood" x1="0" y1="0" x2="0" y2="1">
                <stop offset="0" stop-color="#f3e1c5"/>
                <stop offset="1" stop-color="#e6c89d"/>
              </linearGradient>
              <pattern id="planks" width="120" height="120" patternUnits="userSpaceOnUse">
                <rect width="120" height="120" fill="none"/>
                <path d="M0 0 H120" stroke="rgba(124,45,18,0.15)" stroke-width="6"/>
              </pattern>
            </defs>
            <rect width="1200" height="800" fill="url(#wood)"/>
            <rect width="1200" height="800" fill="url(#planks)" opacity="0.8"/>
            <g stroke="rgba(15,23,42,0.65)" stroke-width="6" fill="none">
              <rect x="80" y="80" width="1040" height="640" rx="26"/>
              <line x1="600" y1="80" x2="600" y2="720"/>
              <circle cx="600" cy="400" r="90"/>
              <rect x="80" y="250" width="190" height="300" rx="18"/>
              <rect x="930" y="250" width="190" height="300" rx="18"/>
              <circle cx="270" cy="400" r="70"/>
              <circle cx="930" cy="400" r="70"/>
            </g>
          </svg>
        `),
        chalk: svgDataUrl(`
          <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 1200 800">
            <defs>
              <filter id="noise">
                <feTurbulence type="fractalNoise" baseFrequency="0.9" numOctaves="2" stitchTiles="stitch"/>
                <feColorMatrix type="matrix"
                  values="1 0 0 0 0
                          0 1 0 0 0
                          0 0 1 0 0
                          0 0 0 0.18 0"/>
              </filter>
            </defs>
            <rect width="1200" height="800" fill="#0b2b26"/>
            <rect width="1200" height="800" filter="url(#noise)"/>
            <g stroke="rgba(248,250,252,0.6)" stroke-width="5" fill="none">
              <rect x="80" y="80" width="1040" height="640" rx="28"/>
              <path d="M120 200 C 300 120, 420 260, 600 200 S 900 300, 1080 220" />
              <path d="M120 520 C 320 600, 460 460, 600 520 S 900 420, 1080 520" />
              <circle cx="600" cy="400" r="90"/>
            </g>
          </svg>
        `),
      };

      function svgDataUrl(svgString) {
        const cleaned = svgString.replace(/\s+/g, " ").trim();
        return `url("data:image/svg+xml;utf8,${encodeURIComponent(cleaned)}")`;
      }

      function applyBackgroundPreset(key) {
        if (key === "grid") {
          field.classList.remove("canvas-bg");
          field.style.backgroundColor = "var(--field-bg)";
          field.style.backgroundImage =
            "linear-gradient(90deg, rgba(107, 114, 128, 0.25) 0, rgba(107, 114, 128, 0.25) 1px, transparent 1px, transparent 72px), " +
            "linear-gradient(180deg, rgba(107, 114, 128, 0.25) 0, rgba(107, 114, 128, 0.25) 1px, transparent 1px, transparent 72px)";
          field.style.backgroundSize = "72px 72px";
          return;
        }

        field.classList.add("canvas-bg");
        field.style.backgroundSize = "cover";
        field.style.backgroundPosition = "center";
        field.style.backgroundRepeat = "no-repeat";
        field.style.backgroundImage = bgPresets[key] || "none";
      }

     

      // ---- Event listeners ----
      field.addEventListener("contextmenu", (e) => e.preventDefault());

      markers.forEach((marker) => {
        marker.addEventListener("contextmenu", (e) => e.preventDefault());
        marker.addEventListener("pointerdown", onMarkerPointerDown);
        marker.addEventListener("pointermove", onMarkerPointerMove);
        marker.addEventListener("pointerup", endMarkerDrag);
        marker.addEventListener("pointercancel", endMarkerDrag);
      });

      

      field.addEventListener("pointerdown", (event) => {
        if (mode === "draw") startDrawing(event);
      
      });

      field.addEventListener("pointermove", draw);
      window.addEventListener("pointerup", stopDrawing);
      window.addEventListener("pointercancel", stopDrawing);

      modeButtons.forEach((button) => {
        button.addEventListener("click", () => setMode(button.dataset.mode));
      });

      backgroundSelect.addEventListener("change", () => {
        applyBackgroundPreset(backgroundSelect.value);
      });

      clearButton.addEventListener("click", clearCanvas);

      

      if (settingsToggle && settingsDrawer) {
        settingsToggle.addEventListener("click", () => {
          const isExpanded = settingsToggle.getAttribute("aria-expanded") === "true";
          settingsToggle.setAttribute("aria-expanded", String(!isExpanded));
          settingsDrawer.hidden = isExpanded;
        });
      }

      if (dotSizeControl) {
        dotSizeControl.addEventListener("input", () => {
          handleDotSizeChange(dotSizeControl.value);
        });
      }

      if (darkModeToggle) {
        darkModeToggle.addEventListener("click", () => {
          setDarkMode(!document.body.classList.contains("dark"));
        });
      }

      if (downloadButton) {
        downloadButton.addEventListener("click", async () => {
          const snapshot = await renderSnapshot();
          const link = document.createElement("a");
          link.download = `grifmaps-${Date.now()}.png`;
          link.href = snapshot.toDataURL("image/png");
          link.click();
        });
      }

      if (restoreDotsButton) {
        restoreDotsButton.addEventListener("click", () => {
          const snapshot = getCurrentState();
          let changed = false;
          markers.forEach((marker) => {
            if (marker.classList.contains("is-hidden")) {
              marker.classList.remove("is-hidden");
              changed = true;
              if (marker.classList.contains("highlight")) {
                createConnector(marker);
              }
            }
          });
          if (changed) {
            pushHistory(snapshot);
          }
          buildMarkerSettings();
        });
      }

      if (savePositionButton) {
        savePositionButton.addEventListener("click", saveCurrentPosition);
      }

      window.addEventListener("keydown", (event) => {
        const target = event.target;
        const isFormField = target instanceof HTMLElement
          && (target.tagName === "INPUT" || target.tagName === "TEXTAREA" || target.tagName === "SELECT" || target.isContentEditable);
        if (isFormField) return;
        if (!(event.ctrlKey || event.metaKey) || event.altKey) return;

        const key = event.key.toLowerCase();
        if (key === "z") {
          event.preventDefault();
          if (event.shiftKey) redo();
          else undo();
        } else if (key === "y") {
          event.preventDefault();
          redo();
        }
      });

      window.addEventListener("resize", () => {
        resizeCanvas();
        refreshMarkerPositions();
        
        refreshConnectorPositions();

        
      });

      // init
      resizeCanvas();
      initializeMarkerColors();
      if (dotSizeControl) {
        handleDotSizeChange(dotSizeControl.value);
      }
      if (window.matchMedia) {
        setDarkMode(window.matchMedia("(prefers-color-scheme: dark)").matches);
      }
      buildMarkerSettings();
      refreshMarkerPositions();
      
      refreshConnectorPositions();
      applyBackgroundPreset(backgroundSelect.value);

      const splashScreen = document.getElementById("splashScreen");
      if (splashScreen) {
        splashScreen.addEventListener("animationend", (event) => {
          if (event.animationName !== "splash-fade-out") return;
          splashScreen.remove();
          document.body.classList.remove("is-loading");
        });
      }
    </script>
  </body>
</html>
